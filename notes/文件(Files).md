# 文件(Files)

## 文件(Files)

### 格式化输入输出

#### `printf()`

`printf()`函数声明: 

````c
int printf(const char *format, ...);
返回值: 输出的字符数
````

`format`表示: 

````c
%[flags][width][.precision][length]specifier
````

| flags (标识) | 描述                                                         |
| :----------- | ------------------------------------------------------------ |
| `-`          | 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。 |
| `+`          | 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。 |
| `(space)`    | 如果没有写入任何符号，则在该值前面插入一个空格。             |
| `0`          | 在指定填充的数字左边放置零（0），而不是空格（参见 width 子说明符）。 |
| `#`          | 与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。<br/>与 e、E 、f 、g 和 G 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 |

| width (宽度) | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| `(number)`   | 要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。 |
| `*`          | 宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 |

````c
printf("%-8d\n", 123);
printf("%8d\n", 123);
printf("%-+8d\n", 123);
printf("%+8d\n", 123);
printf("%+8d\n", -123);
printf("%08d\n", 123);
printf("%*d\n", 8, 123);
````

运行结果: 

```c
123     
     123
+123    
    +123
    -123
00000123
     123
```

| .precision (精度) | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| `.number`         | 小数点后的位数                                               |
| `.*`              | 精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 |

````c
printf("%8.2f\n", 123.123);
printf("%.2f\n", 123.123);
printf("%*.*f\n", 8, 2, 123.123);
````

运行结果: 

````c
  123.12
123.12
  123.12
````

| length (长度) | 描述        |
| ------------- | ----------- |
| `h`           | short       |
| `l`           | long        |
| `L`           | long double |
| `hh`          | 单个字节    |
| `ll`          | longl ong   |

| specifier    | 描述               | specifier | 描述                                                   |
| ------------ | ------------------ | --------- | ------------------------------------------------------ |
| `%i 或者 %d` | int                | `%g`      | 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出 |
| `%u`         | unsigned int       | `%a`      | 十六进制浮点                                           |
| `%o`         | 八进制             | `%c`      | char                                                   |
| `%x`         | 十六进制           | `%s`      | string                                                 |
| `%X`         | 字母大写的十六进制 | `%p`      | 指针                                                   |
| `%f 或者 %F` | float, double      | `%n`      | 读入/写入的字符个数                                    |
| `%e 或者 %E` | 指数形式的浮点数   | `%%`      | 百分号                                                 |

````c
printf("%#x", 20);
int val;
printf("blah %n blah\n", &val);
printf("val = %d\n", val);
````

运行结果: 

````c
0x14
blah  blah
val = 5
````

#### `scanf()`

`scanf()` 函数声明:

```
int scanf(const char *format, ...)
返回值: 读入了几个项目
```

`format`表示:

````c
[=%[*][width][modifiers]type=]
````

| 标识        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| `*`         | 跳过                                                         |
| `width`     | 读取的最大字符数                                             |
| `modifiers` | 为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小：<br />h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x）<br />l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） <br />L ：长双精度型（针对 e、f 和 g） |
| `type`      | 基本等同于`printf()的specifier`<br />多一个`%[]`:  扫描字符集合 |

````c
int num;
scanf("%*d%d", &num);
printf("%d", num);
````

运行结果: 

````
输入:
123 456
输出:
456
````

### 文件输入输出

#### 打开文件的标准代码

````c
#include <stdio.h>
    
int main() {
    FILE* fp = fopen("test.txt", "r"); // "r" -> "read"
   	if (fp) {	
        int num;
        fscanf(fp, "%d", &num);
        printf("%d\n", num);
        fclose(fp);
    }
    else {		// failed to read, return NULL
        printf("Failed to open the file.");
    }
    return 0;
}
````

运行结果:

````c
test.txt: 712
output: 712
````

补充: `int fprintf(FILE *stream, const char *format, ...)`

#### `fopen`

| 参数  | 描述                                                         |
| ----- | :----------------------------------------------------------- |
| `r`   | 打开只读                                                     |
| `r+`  | 打开读写, 从文件头开始                                       |
| `w`   | 打开只写, 不存在则新建, 存在则先清空内容                     |
| `w+`  | 打开读写, 不存在则新建, 存在则先清空内容                     |
| `a`   | 打开追加, 不存在则新建, 存在则从头开始                       |
| `a+`  | 打开读写, 不存在则新建, 读取从头开始, 写只能是追加           |
| `..x` | 只新建, 如果存在则不能打开, 一般加在上述参数后<br />不破坏已有的文件 |

 只有用 **r+** 模式打开文件才能插入内容，**w** 或 **w+** 模式都会清空掉原来文件的内容再来写，**a** 或 **a+** 模式即总会在文件最尾添加内容，哪怕用 fseek() 移动了文件指针位置。

### 二进制文件

- 所有文件最终都是二进制的
- 文本文件无非是用最简单的方式可以读写的文件
- 二进制文件则需要专门的程序来读写
- 文本文件的输入输出是格式化, 可能经过转码

#### 文本 vs 二进制

- Unix 喜欢用文本文件来做数据存储和程序配置
  - 交互式终端 -> 人们喜欢用文本和计算机交流
  - Unix 的 shell 提供了一些读写文本的小程序
- Windows 喜欢用二进制文件
  - DOS 是"草根文化", 不继承和熟悉 Unix 文化
  - PC 刚起步时能力有限, DOS 更加有限, 二进制更接近底层
- 文本方便人类读写, 跨平台
- 文本缺点时输入输出都需要进行格式化
- 二进制缺点是人类读写困难, 不跨平台 (int大小, 大小端......)
- 二进制程序读写更快

#### 程序为什么要文件

- 配置
  - Unix 用文本, Windows 用注册表
- 数据
  - 数据库
- 媒体
  - 媒体文件只能是二进制的
- 当然, 现实中大多通过第三方库来读写文件

#### 二进制读写

````c
size_t fread(void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);
              
size_t fwrite(const void *ptr, size_t size_of_elements, 
             size_t number_of_elements: , FILE *a_file);

const void *ptr: 要读和写的那块内存
size_t size_of_elements: 这块内存多大 二进制文件读写一般是通过对一个结构变量操作进行size_of_elements 表示一个该结构变量大小
size_t number_of_elements: 有几个这样的内存 有几个要读写的结构变量
FILE *a_file: 文件指针
return: 成功读写字节数
````

#### 文件定位

````c
long ftell(FILE* stream);	//现在所在的文件种中的位置
int fseek(FILE *stream, long offset, int whence);
//fseek 设置当前读写点到 offset 处, whence 可以是 //SEEK_SET,SEEK_CUR,SEEK_END 这些值决定是从文件头、当前点和文件尾计算偏移量 offset(字节数)
````

## 位运算

**区分位运算与逻辑运算**

假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：

A = 0011 1100

B = 0000 1101

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与操作，按二进制位进行"与"运算。运算规则：`0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |
| \|     | 按位或运算符，按二进制位进行"或"运算。运算规则：`0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \| B) 将得到 61，即为 0011 1101                           |
| ^      | 异或运算符，按二进制位进行"异或"运算。运算规则：`0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |
| ~      | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=-2;    ~0=-1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| <<     | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |
| >>     | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 | A >> 2 将得到 15，即为 0000 1111                             |

### 位运算 应用

#### `&`

- 让一位或某些位变成 0 : `x & 0xFE` 0xFE: 1111 1110
  - 使得 x 最低位变成 0, 其他不变
- 取一段 : `x & 0xFF`

#### `|`

- 让一位或某些位变成 1 : `x & 0x01` 0x01: 0000 0001
  - 使得 x 最低位变成 1, 其他不变
- 把两个数拼起来 : `0xFF00 |0x00FF`

#### `^`

- 对一个变量用一个值异或两次, 等于什么也没做
  - `x^y^y == x`

#### `<<`

- `x << 1` 等价于 `x *= 2`
- `x << n` 等价于 `x *= 2的n次方`
  - 所有小于`int`的类型, 移位以`int`的方式来做, 结果也是`int`
  - 能移多少位取决于`int`大小

### 位运算 例子

看看数的二进制:

````c
#include <stdio.h>
    
int main() {
    int number;
    scanf("%d", &number);
    unsigned int mask = 1 << 31; // 80 00 00 00 // 100 ... 00
    for (; mask; mask>>=1) {
        printf("%d", mask&number ? 1 : 0);
    }

    return 0;
}
````

运行结果: 

````c
input: 8
output: 00000000000000000000000000001000
````





